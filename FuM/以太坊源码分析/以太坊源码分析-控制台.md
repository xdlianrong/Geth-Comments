# ä»¥å¤ªåŠæ§åˆ¶å°æºç åˆ†æ

è¿›è¡Œæ­¤é¡¹åˆ†æçš„ç›®çš„æ˜¯è€ƒè™‘åˆ°æˆ‘ä»¬ä»¥ååšè‡ªå·±çš„ç³»ç»Ÿï¼Œå°±å¿…é¡»æœ‰è‡ªå·±çš„APIï¼Œè€Œæ§åˆ¶å°åŠRPCè°ƒç”¨å°±æ˜¯APIçš„çª—å£ï¼Œæ‰€ä»¥æƒ³è¦é€šè¿‡æ­¤æ¬¡åˆ†æèƒ½å¤Ÿææ¸…æ¥šä»æˆ‘ä»¬åœ¨æ§åˆ¶å°æ•²ä¸‹æŒ‡ä»¤ä¹‹ååˆ°æ§åˆ¶å°æ˜¾ç¤ºä¸‹ä¸€æ¡æŒ‡ä»¤çš„è¾“å…¥æ ‡è¯†ç¬¦æ—¶ç³»ç»Ÿå†…éƒ¨åˆ°åº•åšäº†ä»€ä¹ˆäº‹ï¼Œä½†æ˜¯è¿™ä¸ªæœ‰äº›éš¾åº¦ï¼Œæ¶‰åŠåˆ°jsè™šæ‹Ÿæœºå’Œrpcè°ƒç”¨ï¼Œæ‰€ä»¥â¬‡ï¸

å¹¶æ²¡æœ‰åˆ†æå®Œæˆï¼Œè¿‡äºæ·±å…¥æºç ï¼Œé‡åˆ°ç“¶é¢ˆã€‚æ—¥æœŸï¼š2020.07.30

åˆ†æå¦‚ä¸‹â¬‡ï¸

å½“æˆ‘ä»¬åœ¨æ§åˆ¶å°è¾“å…¥JavaScriptå‘½ä»¤æ—¶ï¼Œå‘½ä»¤ä¼šé€å…¥./console/console.goä¸­çš„`Evaluate(statement string)`,å¹¶ä¸”æŒ‡ä»¤å°±æ˜¯`statement`ã€‚

```go
// Evaluate executes code and pretty prints the result to the specified output
// stream.
func (c *Console) Evaluate(statement string) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Fprintf(c.printer, "[native] error: %v\n", r)
		}
	}()
	c.jsre.Evaluate(statement, c.printer)
}
```

å¯ä»¥çœ‹åˆ°é™¤äº†ä¸€ä¸ªdeferä¹‹å¤–ï¼Œstatementè¢«ç›´æ¥é€åˆ°jsreå»æ‰§è¡Œï¼Œc.printerè®¤ä¸ºæ˜¯æ§åˆ¶å°çš„æ ‡å‡†è¾“å‡ºå¯¹è±¡ã€‚

ä¸‹é¢çœ‹jsreçš„Evaluateå‡½æ•°

```go
// Evaluate executes code and pretty prints the result to the specified output stream.
func (re *JSRE) Evaluate(code string, w io.Writer) {
	//æ‰§è¡Œre.Do(func(){}) funä¸ºå›è°ƒå‡½æ•°
	re.Do(func(vm *goja.Runtime) {
		val, err := vm.RunString(code) /* FuM:åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œæ§åˆ¶å°çš„æŒ‡ä»¤ */
		if err != nil {
			prettyError(vm, err, w)
		} else {
			// åœ¨æ§åˆ¶å°è¾“å‡ºç»“æœ
			prettyPrint(vm, val, w)
		}
		fmt.Fprintln(w)
	})
}
```

å¯ä»¥çœ‹åˆ°ï¼Œstatementæˆä¸ºcodeï¼Œè€Œc.printeræˆä¸ºäº†io.Writerç±»å‹çš„w

æ­¤å‡½æ•°æ‰§è¡Œäº†re.Do(func(){})ï¼Œæ³¨æ„funcæ˜¯ä½œä¸ºå‚æ•°ä¼ å…¥çš„ï¼Œå¹¶æ²¡æœ‰åœ¨è¿™é‡Œç«‹å³æ‰§è¡Œï¼Œè€Œæ˜¯ä¼šåœ¨Do()ä¸­è¢«è°ƒç”¨ï¼Œæˆ‘ä»¬çœ‹ä¸‹Do()åšäº†ä»€ä¹ˆäº‹

```go
// Do executes the given function on the JS event loop.
func (re *JSRE) Do(fn func(*goja.Runtime)) {
	done := make(chan bool)
	req := &evalReq{fn, done}
	// å°†è¦æ‰§è¡Œçš„æŒ‡ä»¤å‡½æ•°fnåŠ ä¸Šdoneä½œä¸ºreqå†™å…¥re.evalQueue,re.evalQueueè¢«æœ¬æ–‡ä»¶ä¸­çš„å‡½æ•°runEventLoop()æ‰€ç›‘å¬
	re.evalQueue <- req
	<-done
}
```

åˆ›å»ºäº†ä¸€ä¸ªé€šé“åä¸ºdoneï¼Œå¯ä»¥çœ‹åˆ°ç¬¬7è¡Œä½¿ç”¨äº†<-doneï¼Œè€Œåœ¨ç¬¬4è¡Œä¹ŸæŠŠdoneä½œä¸ºå‚æ•°ä¼ å…¥äº†reqå¹¶åœ¨ç¬¬å…­è¡Œä¼ å…¥re.evalQueueã€‚è¿™æ ·åšæ˜¯ä¸ºäº†ä¿è¯Do()å‡½æ•°èƒ½å¤ŸæŠŠæ•´ä¸ªæŒ‡ä»¤æ‰§è¡Œå®Œæ¯•ä¹‹åå†è¿”å›ä¸Šä¸€å±‚ï¼Œå› ä¸ºå¦‚æœdoneä¸­æ²¡æœ‰ä»»ä½•æ•°æ®ï¼Œç¬¬7è¡Œä¼šä¸€ç›´é˜»å¡ç­‰å¾…ï¼Œç›´åˆ°å‘½ä»¤æ‰§è¡Œå®Œæ¯•ã€‚

æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦å…³æ³¨å“ªä¸ªåç¨‹ç›‘å¬äº†re.evalQueueï¼Œç”±å‘½åå¯çŸ¥è¿™æ˜¯ä¸€ä¸ªæ‰§è¡Œé˜Ÿåˆ—ã€‚

ç»è¿‡å…¨å±€æœç´¢ï¼Œæ‰¾åˆ°äº†æœ‰ä¸”ä»…æœ‰ä¸€å¤„ç›‘å¬äº†re.evalQueueé€šé“ï¼Œå¦‚æ³¨é‡Šä¸­æ‰€è¯´ï¼Œè¢«æœ¬æ–‡ä»¶ä¸­çš„å‡½æ•°runEventLoop()æ‰€ç›‘å¬ã€‚ä¸éš¾æƒ³åˆ°ï¼ŒrunEventLoop()åœ¨ä»¥å¤ªåŠæœåŠ¡å¯åŠ¨æ—¶å°±å·²ç»æ‰§è¡Œï¼Œå‡½æ•°loopä¹‹å‰é‚£ä¸€éƒ¨åˆ†å°±å·²ç»åœ¨å¯åŠ¨æ—¶æ‰§è¡Œå®Œæ¯•ï¼Œåªæœ‰loopé‚£éƒ¨åˆ†ä¸€ç›´åœ¨å¾ªç¯ç›‘å¬ç›¸å…³é€šé“ã€‚ç”±loopä¹‹å‰çš„ä»£ç å¯ä»¥çœ‹å‡ºæ¥ï¼Œloopä¹‹å‰ä¸€ç›´åœ¨å£°æ˜åŒ¿åå‡½æ•°ï¼Œåé¢åœ¨re.vmè™šæ‹Ÿæœºä¸­ä¹Ÿåœ¨å£°æ˜åŒ¿åå‡½æ•°ã€‚

```go
// This function runs the main event loop from a goroutine that is started
// when JSRE is created. Use Stop() before exiting to properly stop it.
// The event loop processes vm access requests from the evalQueue in a
// serialized way and calls timer callback functions at the appropriate time.

// Exported functions always access the vm through the event queue. You can
// call the functions of the goja vm directly to circumvent the queue. These
// functions should be used if and only if running a routine that was already
// called from JS through an RPC call.
func (re *JSRE) runEventLoop() {
	defer close(re.closed)

	r := randomSource()
	re.vm.SetRandSource(r.Float64)

	registry := map[*jsTimer]*jsTimer{}
	ready := make(chan *jsTimer)

	newTimer := func(call goja.FunctionCall, interval bool) (*jsTimer, goja.Value) {
		delay := call.Argument(1).ToInteger()
		if 0 >= delay {
			delay = 1
		}
		timer := &jsTimer{
			duration: time.Duration(delay) * time.Millisecond,
			call:     call,
			interval: interval,
		}
		registry[timer] = timer

		timer.timer = time.AfterFunc(timer.duration, func() {
			ready <- timer
		})

		return timer, re.vm.ToValue(timer)
	}

	setTimeout := func(call goja.FunctionCall) goja.Value {
		_, value := newTimer(call, false)
		return value
	}

	setInterval := func(call goja.FunctionCall) goja.Value {
		_, value := newTimer(call, true)
		return value
	}

	clearTimeout := func(call goja.FunctionCall) goja.Value {
		timer := call.Argument(0).Export()
		if timer, ok := timer.(*jsTimer); ok {
			timer.timer.Stop()
			delete(registry, timer)
		}
		return goja.Undefined()
	}
	re.vm.Set("_setTimeout", setTimeout)
	re.vm.Set("_setInterval", setInterval)
	re.vm.RunString(`var setTimeout = function(args) {
		if (arguments.length < 1) {
			throw TypeError("Failed to execute 'setTimeout': 1 argument required, but only 0 present.");
		}
		return _setTimeout.apply(this, arguments);
	}`)
	re.vm.RunString(`var setInterval = function(args) {
		if (arguments.length < 1) {
			throw TypeError("Failed to execute 'setInterval': 1 argument required, but only 0 present.");
		}
		return _setInterval.apply(this, arguments);
	}`)
	re.vm.Set("clearTimeout", clearTimeout)
	re.vm.Set("clearInterval", clearTimeout)

	var waitForCallbacks bool

loop:
	for {
		select {
		case timer := <-ready:
			// execute callback, remove/reschedule the timer
			var arguments []interface{}
			if len(timer.call.Arguments) > 2 {
				tmp := timer.call.Arguments[2:]
				arguments = make([]interface{}, 2+len(tmp))
				for i, value := range tmp {
					arguments[i+2] = value
				}
			} else {
				arguments = make([]interface{}, 1)
			}
			arguments[0] = timer.call.Arguments[0]
			call, isFunc := goja.AssertFunction(timer.call.Arguments[0])
			if !isFunc {
				panic(re.vm.ToValue("js error: timer/timeout callback is not a function"))
			}
			call(goja.Null(), timer.call.Arguments...)

			_, inreg := registry[timer] // when clearInterval is called from within the callback don't reset it
			if timer.interval && inreg {
				timer.timer.Reset(timer.duration)
			} else {
				delete(registry, timer)
				if waitForCallbacks && (len(registry) == 0) {
					break loop
				}
			}
			// æ¥æ”¶åˆ°è¦æ‰§è¡Œçš„æŒ‡ä»¤
		case req := <-re.evalQueue:
			// run the code, send the result back
			req.fn(re.vm)
			close(req.done)
			if waitForCallbacks && (len(registry) == 0) {
				break loop
			}
		case waitForCallbacks = <-re.stopEventLoop:
			if !waitForCallbacks || (len(registry) == 0) {
				break loop
			}
		}
	}

	for _, timer := range registry {
		timer.timer.Stop()
		delete(registry, timer)
	}
}
```

loopå†…æœ‰ä¸‰ä¸ªç›‘å¬

+ `case timer := <-ready case`ï¼Œè¿˜ä¸æ¸…æ¥šä½œç”¨

+ `req := <-re.evalQueue`,å‘½ä»¤æ‰§è¡Œé˜Ÿåˆ—

+ `case waitForCallbacks = <-re.stopEventLoop`ï¼Œåœæ­¢ç›‘å¬ä¿¡å·

æˆ‘ä»¬ä¸»è¦çœ‹`req := <-re.evalQueue`è¿™ä¸€ä¸ªcase

```go
			// æ¥æ”¶åˆ°è¦æ‰§è¡Œçš„æŒ‡ä»¤
		case req := <-re.evalQueue:
			// run the code, send the result back
			req.fn(re.vm)
			close(req.done)
			if waitForCallbacks && (len(registry) == 0) {
				break loop
			}
```

`req := &evalReq{fn, done}`

`fn`æ˜¯åˆšæ‰Do()ä¸­çš„å›è°ƒå‡½æ•°ï¼Œå†çœ‹æ­¤å‡½æ•°

```go
// Evaluate executes code and pretty prints the result to the specified output stream.
func (re *JSRE) Evaluate(code string, w io.Writer) {
	//æ‰§è¡Œre.Do(func(){}) funä¸ºå›è°ƒå‡½æ•°
	re.Do(func(vm *goja.Runtime) {
		val, err := vm.RunString(code) /* FuM:åœ¨è™šæ‹Ÿæœºä¸­è¿è¡Œæ§åˆ¶å°çš„æŒ‡ä»¤ */
		if err != nil {
			prettyError(vm, err, w)
		} else {
			// åœ¨æ§åˆ¶å°è¾“å‡ºç»“æœ
			prettyPrint(vm, val, w)
		}
		fmt.Fprintln(w)
	})
}
```

å…ˆé€šè¿‡vm.RunString(code)æ‰§è¡Œæ§åˆ¶å°æŒ‡ä»¤ï¼Œä¹‹åå¦‚æœerrå°±è¾“å‡ºé”™è¯¯ï¼Œæ²¡æœ‰errå°±è¾“å‡ºç»“æœï¼Œæ‰€ä»¥é‡ç‚¹åœ¨vm.RunString(code)

```go
// RunString executes the given string in the global context.
func (r *Runtime) RunString(str string) (Value, error) {
	return r.RunScript("", str)
}
```

vm.RunString(code)ç›¸å½“ç®€å•ï¼Œæˆ‘ä»¬æ¥ç€çœ‹r.RunScript("", str)

```go
// RunScript executes the given string in the global context.
func (r *Runtime) RunScript(name, src string) (Value, error) {
	p, err := Compile(name, src, false)

	if err != nil {
		return nil, err
	}

	return r.RunProgram(p)
}
```

è¿˜ä¸æ¸…æ¥šnameçš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Œå¯ä»¥çœ‹åˆ°RunString()ä¸­å¯¹RunScript()ä¼ å…¥çš„nameä¸ºç©ºå­—ç¬¦ä¸²ã€‚

å…ˆå¯¹æŒ‡ä»¤è¿›è¡Œäº†ç¼–è¯‘å¾—åˆ°pï¼Œç„¶åè¿è¡Œr.RunProgram(p)

ç¼–è¯‘è¿‡ç¨‹æœ‰äº›ç¹çï¼Œé€šè¿‡è°ƒè¯•å¯ä»¥çœ‹åˆ°æœ€ç»ˆç»“æœã€‚

![image-20200730100712237](./images/p_in_RunScript.png)

æ¥ä¸‹æ¥çœ‹r.RunProgram(p)

```go
// è¿™ä¸ªå‡½æ•°è™½ç„¶æœ€ååªæœ‰ä¸€ä¸ªreturn ï¼Œä½†æ˜¯è¿™å¹¶ä¸æ˜¯è¯´ä»€ä¹ˆéƒ½ä¸returnï¼Œè¦returnçš„å€¼å·²ç»åœ¨å‡½æ•°å£°æ˜ä¸­å£°æ˜ï¼Œå³(result Value, err error)
// resultå’Œerrä¸¤ä¸ªå˜é‡å¯ä»¥åœ¨å‡½æ•°ä½“ä¸­ç›´æ¥èµ‹å€¼ä½¿ç”¨ï¼Œåœ¨returnçš„æ—¶å€™ä¼šç›´æ¥è¿”å›åˆ°ä¸Šä¸€æ¬¡å±‚
// RunProgram executes a pre-compiled (see Compile()) code in the global context.
func (r *Runtime) RunProgram(p *Program) (result Value, err error) {
	defer func() {
		if x := recover(); x != nil {
			if intr, ok := x.(*InterruptedError); ok {
				err = intr
			} else {
				panic(x)
			}
		}
	}()
	recursive := false
	if len(r.vm.callStack) > 0 {
		recursive = true
		r.vm.pushCtx()
	}
	r.vm.prg = p
	r.vm.pc = 0
	ex := r.vm.runTry()
	if ex == nil {
		result = r.vm.pop()
	} else {
		err = ex
	}
	if recursive {
		r.vm.popCtx()
		r.vm.halt = false
		r.vm.clearStack()
	} else {
		r.vm.stack = nil
	}
	return
}
```

æ­¤å‡½æ•°å…ˆæ£€æŸ¥äº†vmä¸­çš„å †æ ˆï¼Œç„¶åæ‰§è¡Œpï¼Œresultæ˜¯è¦è¿”å›çš„ç»“æœï¼Œå¯ä»¥çœ‹åˆ°result = r.vm.pop()æ˜¯å¼¹å‡ºç»“æœï¼Œé‚£ä¹ˆæ‰§è¡Œè¿‡ç¨‹åœ¨ex := r.vm.runTry()ä¸­ï¼Œçœ‹ä¸‹runTry()åšäº†ä»€ä¹ˆï¼Œexæ˜¯æŠ›å‡ºçš„å¼‚å¸¸(Exception)ã€‚

```go
func (vm *vm) runTry() (ex *Exception) {
	return vm.try(vm.run)
}
```

vm.runæ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä¼šåœ¨åé¢è§£é‡Šï¼Œå…ˆçœ‹try(f func())

```go
func (vm *vm) try(f func()) (ex *Exception) {
	var ctx context
	vm.saveCtx(&ctx)

	ctxOffset := len(vm.callStack)
	sp := vm.sp
	iterLen := len(vm.iterStack)
	refLen := len(vm.refStack)

	defer func() {
		Â·Â·Â·Â·Â·Â·
	}()

	f()
	return
}
```

ä¸»è¦å°±æ˜¯æœ€åæ‰§è¡Œçš„f()ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢è¯´çš„vm.runï¼Œvm.runå¦‚ä¸‹

```go
func (vm *vm) run() {
	vm.halt = false
	interrupted := false
	ticks := 0
	for !vm.halt {
		if interrupted = atomic.LoadUint32(&vm.interrupted) != 0; interrupted {
			break
		}
		vm.prg.code[vm.pc].exec(vm)
		ticks++
		if ticks > 10000 {
			runtime.Gosched()
			ticks = 0
		}
	}

	if interrupted {
		vm.interruptLock.Lock()
		v := &InterruptedError{
			iface: vm.interruptVal,
		}
		atomic.StoreUint32(&vm.interrupted, 0)
		vm.interruptVal = nil
		vm.interruptLock.Unlock()
		panic(v)
	}
}
```

æ‰§è¡Œå‘½ä»¤çš„è¯­å¥åœ¨ç¬¬9è¡Œvm.prg.code[vm.pc].exec(vm)ï¼Œæˆ‘ä»¬å…ˆçœ‹ä¸‹vmé‡Œé¢éƒ½æœ‰ä»€ä¹ˆå†…å®¹

![vm_in_vm.run](./images/vm_in_vm.run.png)

æ­¤æ—¶vm.prg.code[vm.pc]æ˜¯getVar1ç±»å‹çš„"eth"ï¼Œäºæ˜¯åˆ°äº†ä¸‹é¢è¿™ä¸ªå‡½æ•°

```go
func (n getVar1) exec(vm *vm) {
	name := string(n)
	var val Value
	for stash := vm.stash; stash != nil; stash = stash.outer {
		if v, exists := stash.getByName(name, vm); exists {
			val = v
			break
		}
	}
	if val == nil {
		val = vm.r.globalObject.self.getStr(name)
		if val == nil {
			vm.r.throwReferenceError(name)
		}
	}
	vm.push(val)
	vm.pc++
}
```

ä¸‹é¢å°±æ˜¯å¯¹ethè¿™ä¸ªæŒ‡ä»¤çš„è§£æï¼Œé‡åˆ°ç“¶é¢ˆğŸ˜«

å°è¯•ç›´æ¥å¢åŠ æ–°çš„APIï¼Œå¯è§[ä»¥å¤ªåŠå¢åŠ API](../ä»¥å¤ªåŠå¢åŠ API/ä»¥å¤ªåŠå¢åŠ API.md)ä¸€æ–‡ã€‚

